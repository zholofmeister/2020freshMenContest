- 1003

  显然最优情况是a石头对b剪刀，a剪刀对b布，a布对b石头，这三种情况相互独立，互不干扰，所以答案就是` min(a石头，b剪刀) + min(a剪刀，b布) + min(a布，b石头)`。

​       时间复杂度：`O(1)`

- 1004

  这题如果硬想的话应该有很多种思路，这里只讲找规律的做法。

  我们设dp\[i]\[j]表示棋子一开始在<i,j>马老师是输还是赢，0表示输，1表示赢，现在已知dp\[0]\[0]为0，那么就可以在小棋盘里(比如20x20)进行必胜必败态转换打表找规律。

  时间复杂度:`O(1)`

  ~~~c++
  for(int i=0; i=20; ++i){  //打表找规律
          for(int j=0; j<=20; ++j){
              if(i==0 && j==0) continue;
              bool findlose=false;
              if(!dp[i-1][j] && i-1>=0) findlose=true;
              if(!dp[i][j-1] && j-1>=0) findlose=true;
              if(!dp[i-2][j] && i-2>=0) findlose=true;
              if(!dp[i][j-2] && j-2>=0) findlose=true;
              if(findlose) dp[i][j]=1;
          }
      }
      for(int i=0; i<=20; ++i){
          for(int j=0; j<=20; ++j){
              cout<<dp[i][j]<<' ';
          } cout<<'\n';
      }
  ~~~



- 1007

  预备知识：深度优先搜索

  做法：

  1. 数学公式
  2. 网络流
  3. 全排列枚举所有情况（用深度优先搜索实现）

  因为不赢的情况一共就六种<a石头，b石头>,<a石头，b布>,<a剪刀，b剪刀>,<a剪刀，b石头>,<a布，b布>,<a布，b剪刀>，假设他们分别为a,b,c,d,e,f操作，那么他们之间的顺序是无所谓的，比如依次做acbcb操作和依次做accbb是一样的，所以就可以对这六种情况进行全排列，然后分别贪心减掉两两之间的最小值加入答案，维护答案即可。

  时间复杂度:`O(6!)`



- 1008

  预备知识：欧拉回路性质，floyd最短路，状压dp

  首先对于欧拉回路：所有点的度数都为偶数。因为所有点至少经过一次，那么可以把题意转换成最少加多少条边使得图满足以上结论。
  而加边的目的是为了把奇度数转化为偶度数，先floyd一下得到全源最短路。dp[i]表示状态i下度数为偶数的最小花费，因为n<=15,想到状压dp，挑两个奇度数的点转移即可。

  时间复杂度:`O(2^n*n*n)`

